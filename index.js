!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("three"),require("@seregpie/three.text-texture")):"function"==typeof define&&define.amd?define(["three","@seregpie/three.text-texture"],t):((e="undefined"!=typeof globalThis?globalThis:e||self).THREE=e.THREE||{},e.THREE.TextPlane=t(e.THREE,e.THREE.TextTexture))}(this,(function(e,t){"use strict";function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o=i(t);let r=class extends e.Mesh{constructor({fontSize:t=1,...i}={},r){super(new e.PlaneGeometry,r);let n=new o.default({fontSize:t,...i});this.material.map=n}onBeforeRender(e,t,i){let{material:o}=this,{map:r}=o;if(r.checkFontFace()){let{scale:t}=this,{height:o,width:n}=r;n&&o?(t.setX(n).setY(o),r.setOptimalPixelRatio(this,e,i),r.redraw()):t.setScalar(1)}else r.loadFontFace()}dispose(){let{geometry:e,material:t}=this,{map:i}=t;e.dispose(),i.dispose(),t.dispose()}};return["alignment","color","fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineGap","padding","strokeColor","strokeWidth","text"].forEach((e=>{Object.defineProperty(r.prototype,e,{get(){return this.material.map[e]},set(t){this.material.map[e]=t}})})),r.prototype.isTextPlane=!0,r}));
